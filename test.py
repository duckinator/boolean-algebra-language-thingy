#!/usr/bin/env python3

"""
1*1 = 1
1*0 = 0
1+1 = 1
1+0 = 1

character       ||  NEGATE_NEXT | IDENTIFIER | OPERATOR
================||=====================================
   !            ||    1         | 0          | 0
   &            ||    0         | 0          | 1
   |            ||    0         | 0          | 1
[a-zA-Z0-9.-]+
"""

from pprint import pprint

from collections import namedtuple
from enum import Enum
import string


class TokenType(Enum):
    """The possible kinds of Tokens."""
    UNINITIALIZED = 0
    IDENTIFIER = 1
    OPERATOR = 2


class OperatorType(Enum):
    """The possible kinds of Operator."""
    NONE = 0
    AND = 1
    OR = 2
    OPEN_PAREN = 3
    CLOSE_PAREN = 4


"""
The class representing a Token generated by the parser.
- negated is only valid if type is IDENTIFIER.
- operator_type is only valid if type is OPERATOR.
"""

class Token:
    def __init__(self, type=None, value=None, negated=False, operator_type=None):
        if type is None:
            self.type = TokenType.UNINITIALIZED
        else:
            self.type = type

        if value is None:
            self.value = ''
        else:
            self.value = value

        self.negated = negated

        if operator_type is None:
            self.operator_type = OperatorType.NONE
        else:
            self.operator_type = operator_type

    def __repr__(self):
        return f"<Token type={self.type.name} value={self.value!r} negated={self.negated} operator_type={self.operator_type.name}>"


def tokenize(code):
    """Given code, returns a sequence of Tokens."""
    whitespace = string.whitespace
    identifier_tokens = string.ascii_letters + string.digits + '.-'
    operator_tokens = {
        '&': OperatorType.AND,
        '|': OperatorType.OR,
        '(': OperatorType.OPEN_PAREN,
        ')': OperatorType.CLOSE_PAREN,
    }

    tokens = []
    token = Token()
    for c in code:  # pylint: disable=invalid-name
        if c in whitespace:
            # We reached the end of a token. Append it, and create a new one.
            tokens.append(token)
            token = Token()
            continue

        if token.type == TokenType.UNINITIALIZED:
            # This means we're either at the beginning
            if c == '!':
                token.type = TokenType.IDENTIFIER
                token.negated = True
                continue
            elif c in identifier_tokens:
                token.type = TokenType.IDENTIFIER
            elif c in operator_tokens.keys():
                token.type = TokenType.OPERATOR

        # If it's a right parenthesis, it's allowed to touch adjacent things,
        # so make it its own token.
        if c == ')' and token.type == TokenType.IDENTIFIER:
            tokens.append(token)
            token = Token()
            token.type = TokenType.OPERATOR

        token.value += c

        if token.type == TokenType.OPERATOR:
            token.operator_type = operator_tokens.get(token.value, None)

        # If it's an left parenthesis, it's allowed to touch adjacent things.
        if c == '(':
            tokens.append(token)
            token = Token()

    # Add the final token.
    tokens.append(token)

    return tokens


def parse(tokens):
    pass


class Interpreter:
    def __init__(self, code_or_tokens):
        if isinstance(str, code_or_tokens):
            self.tokens = parse(code_or_tokens)
        else:
            self.tokens = code_or_tokens

    def run(self):
        print(self.tokens)



def main():
    programs = [
        "!website_up OR !search AND (!elasticsearch.http OR !elasticsearch.process)",
        "!website_up AND !search AND ssh AND search.local AND elasticsearch.http AND elasticsearch.process",
        "!website_up AND !search AND !ssh",
        "!website_up AND !search AND ssh AND !elasticsearch.process",
        "!website_up AND !search AND ssh AND !elasticsearch.http AND elasticsearch.process",
        "website_up AND !search",
    ]

    for program in programs:
        tokens = tokenize(program)
        pprint(tokens)
        #Interpreter(tokens).run()
        exit()


if __name__ == "__main__":
    main()
